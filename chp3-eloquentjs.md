# What is a **function**, how can you call it and define it?
>A **function** is a way of wrapping a piece of _program_ in a **value**. It helps with structuring and streamlining _programs_. You can define a **function** in the same way that a **variable** is declared, by wrapping it in a **value** for a **variable**. You can call a **function** simply by writing it and declaring its **value**. A _result_ statement is needed if a **function** produces more than a _side effect_, in other words is producing an output.
>>[var square = function(x) {
  return x * x;
  }; console.log(square(12));]

>## What are **parameters** and _scopes_?
**Parameters** are like regular **variables**, they're a part of a **function's** _caller_ as opposed to its initial _body_. **Parameters** are specified after a **function** is defined in code.
_Scopes_ can either be _local_ or **global**. If a **variable** is defined within a **function's** _body_, then it stays local within the **function** and its **parameters**, as opposed to if a **variable** outside of a **function's** _body_, which in turn makes its _scope_ **global**.
### What's a _nested scope_?
A _nested scope_ can be defined as a _scope_ within another. A _local scope_ can identify all the _local scopes_ within it. The **variables** in blocks around a **function's** definition are within a **function's** _scope_, including the **variables** within the **function** as well as the **variables** at the top of the **program**. This is called **_lexical scoping_**. Moreover, **functions** are the only things that create new _scopes_.
Furthermore, **recursion** can be useful when dealing with problems that require several branches, which can in turn have their own sub-branches.
### What's a **declaration notation** and where it it placed in the _control flow_?
There's a shorthand **declaration notation** for **functions**, which can be declared simply using the **function keyword** at the start of a **statement**. By declaring a **function** it's removed from the normal top-to-bottom _control flow_ and are moved to the top of their _scope_ and can be applied by all code in its _scope_. However, **functions** **_cannot_** be declared within a **conditional loop** or _block_. It produces uncertain and unpredictable effects, so therefore this practice should be avoided.
### What is the **call stack**?
The **call stack** can be defined as the context from which a **function** was called. When a **function** is called after its definition, control jumps back to the definition and executes the **function's** _body_, and then goes back to where the **function** was called (usually after its definition) and then executes the rest of the _program_. Since after a **function's** execution, control jumps back to the context or where the **function** was called, the computer has to remember the context, this is called the **call stack**. Every time a **function** is called, it's placed at the top of the **stack**. After a **function** returns, it removes the top context from the **stack** and proceeds with execution. Storing a **call stack** require and uses memory, if a **stack** is too big, the computer will fail because of _"too much recursion"_ or being _"out of stack space"_. This is caused by having an infinite back-and-forth between two **functions**, or rather would be infinite given infinite **stack** space.
##### What's an **optional argument**?
A **function** can have multiple **arguments**, but it only needs one to properly execute. There's no ceiling on how many **optional arguments** a **function** can have, which can be a problem because you can add too many or too little **optional arguments** for a **function**. The upside is that enables **functions** to have multiple options for **argument** when executing.
### What's _closure_ and **recursion**?
_Closure_ is the ability to reference an instance of _local_ **variables** within a **function**. The concept of _closure_ abolishes the stress of juggling various **variables** and actually enables further creativity in using **function values**.
A **function** that calls itself is called a **recurive function**. **Recursion** allows for a different style of writing **functions** by virute of enabling **functions** to call themselves. The problem with **recursion** is that in **JavaScript**, it's significantly slower to execute than a _loop_ is. However, it is a much more elegant way of programming. Furthermore, **recursion** can be useful when dealing with problems that require several branches, which can in turn have their own sub-branches.
###### What are **function** _side effects_?
**Function** _side effects_ are a byproduct of some **functions**. _Pure_ **functions** have no _side effects_ and only produce a **return value**. **Functions** that create **values** are more versatile than **functions** that create _side effects_. An extremely important **function** such as _console.log_ would be almost impossible to define without _side effects_ for instance.
