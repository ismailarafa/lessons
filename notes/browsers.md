# How do browsers render websites?

Browsers' main components are the bindings, which is the part dealing with the OS. The rendering component, which deals with constructing the web page from HTML that it gets; or parsing, layout and painting. Lastly, it has the JavaScript virtual machine, which is self-explanatory. A high level flow of how browsers render pages is it parses HTML and CSS first, then converts them to a render or frame tree, which is then layed out on the page; i.e layout and lastly it paints the content. Parsing HTML is forgiving by nature. Some tags can halt HTML rendering such as `<script>` tags as well as `<link>` and `<style>`. Speculative parsing is when rendering halts, the browser creates another thread and looks ahead rendering images or style sheets, it fetches and renders them in the meantime. In order for the browser to layout the render tree, it recursively traverses the nodes, figuring out their positions and sizes as well as layout its children. It incrementally lays out elements through batch layouts, by grouping elements; this process is asynchronous. Immediate layout triggers when doing a font-size change, browser resize, or accessing certain properties in JavaScipt such as `node.offsetHeight`. The final step of painting the page happens by the browser taking the layed out render trees, creating layers from the bottom up (i.e `z-index`) and incrementally painting. Painting produces a bitmap from each layer, that is then uploaded to the GPU as a texture, which composites the textures into a final image to render. Sometimes inlining critical CSS speeds up first paint times in the `<head>` element of the HTML document.

## What are a browser's components?

Browsers consist of an UI, browser engine, rendering engine, networking, JS interpreter, UI backend and data persistence. UI works with UI backend to use widgets, while browser engine works as an intermediary between UI and rendering engine. The rendering engine is the part that parses HTML, CSS and JS and renders it in the browser. Rendering engine deals with networking; or making requests fetching other resources, JS interpreter to process JS and the UI backend. Data persistence deals with cookies, cache, local storage, etc...

### What is the parsing flow?

Parsing flow starts with tokenization where the text transforms to semantic tokens, creating the parse tree.

#### What is not in the render tree?

Non-visual elements like `<head>`, `<title>` and `<script>` elements, as well as nodes hidden using `display: none;`.

##### What are the types of rendering engines?

Different browsers use different rendering engines. IE uses Trident, while Firefox uses Gecko and Safari uses WebKit. Chrome and Opera (v15+) use Blink, a fork of WebKit. WebKit is an open source rendering engine starting for the Linux platform but then modified by Apple to support Mac and Windows.

###### What is parsing?

Parsing is two sub-processess, lexical analysis and syntax analysis. The former, which is also named the lexer or tokenizer, is the process of turning the input into tokens or the language vocabulary. Then syntax analysis applies the language's syntax rules by constructing a parse tree with the valid tokens obtained from the lexer. The parser is iterative, asking the lexer for a new token and tries to match it with a syntax rule. If it matches a rule, the parse tree adds the token and the parser asks the lexer for another token. If the token doesn't match a syntax rule, the parser stores the token internally and keeps asking the lexer for tokens until a rule matching all internally stored tokens appears. If no such rule arises, the parser will raise an exception as a syntax error.

##### What are the types of parsers?

Regular parsers can parse a language if its grammar is context-free grammar, meaning it can be entirely expressed as BNF. `expression := term operation term ; operation := PLUS | MINUS ; term := INTEGER | expression`. Parsers have two types; top down parsers and bottom up parsers, where the former examines the high level structure of the syntax and tries to find a rule match. The latter starts from the low level rules until high level rules apply. WebKit uses two parser generators, Flex for creating a lexer and Bison for creating a parser, where Flex contains regex definitions of the tokens and Bison contains the languague syntax rules in BNF format.

### How is HTML parsed?

HTML being a not context-free grammar language unlike CSS, JS as well as incompatible with the BNF format; it needs a different format of parsing. The format for defining is HTML-DTD (Document Type Definition) and it's not context-free grammar. The difference between XML and HTML parsing is that HTML is more forgiving, while XML is less lenient. Parsing HTML is also reentrant meaning that the source code changes during parsing due to dynamic code, scripts, and `document.write()` can add extra tokens, so the parse can change the input. Browsers then build custom parsers for HTML meeting the HTML5 specification, where the algorithm consists of two stages, tokenization and tree construction also known as the DOM or document object model. The initial state of parsing HTML is the data state when the character `<` occurs, the state changes to Tag open state. Consuming a-z characters causes creation of start tag token, where the state changes to Tag name state. until the `>` character occurs. Then each character appends to the new token name. The state changes back to data state once the token goes into the DOM, and it goes on as before until it reaches the closing tags of each element and creates an end tag token. When the DOM builds, each token has a DOM element created for it and added to the tree and also the stack of open elements, which corrects nesting mismatches and unclosed tags. The algorithm is also known as a state machine, the states are also known as insertion modes. First mode is initial mode, receiving the `<html>` token will cause a move to the before html mode causing the creation of the HTMLHtmlElement and appending of it to the root document object. The state will then change before head, the `<body>` token is then received, an HTMLHeadElement created implicitly will take its place in the tree. The parser goes into the in head mode, the after head mode, creating the HTMLBodyElement and then goes into in body mode. When parsing finishes, the browser marks the document as interactive and starts parsing deferred scripts. The document state will be complete and a load event will fire.

#### How are scripts processed in browsers?

The web has a synchronous model for processing scripts. When the parser reaches a `<script>`, the parsing of the document halts until the script executes. If the resource is external, then parsing halts as the browser fetches it from the network, also synchronously. A `defer` attribute will not halt the document parsing and executes after the parsing of the document. HTML5 introduced an `async` attribute that causes the script to parse and execute by a different thread. Both WebKit and Firefox optimize script execution by assigning a thread the parsing of the rest of the document, finding out what other resources need to load from the network and loads them. This optimization is speculative parsing and it causes resources to load on parallel connections, generally improving speed, note that it doesn't alter the DOM tree, which the main parses does.

##### How are stylesheets processed in browsers?

Stylesheets are different from scripts when it comes to browsers handling them. Firefox will block any script when there is a loading stylesheet or it's parsed, while WebKit blocks scripts that try to access certain style properties that unloaded stylesheets could affect.

### What is a render tree?

During DOM construction, the browser constructs the render tree comprised of DOM elements and computed styles, the render tree enables the painting of the contents in the correct order. Firefox calls render tree elements frames while WebKit uses the term renderer or render object. In Firefox, there's a registered listener for DOM updates that delegates frame creation to the `FrameConstructor` resolving styles and creating the frame. In WebKit, the process of resolving styles and creating a frame is attachment, where each DOM node has an attach method, and attachment is synchronous.

#### How are styles computed in the browser?

Building the render tree requires styles computation including inline styles, visual properties in HTML and external stylesheets. Styles computation has a couple of difficulties such as the style data being a large construct holding a lot of style properties could cause memory problems. Second, finding matching rules if not optimized can cause performance issues, meaning that some overly specific selectors cause too much traversal of the tree thus hindering performance. Lastly, applying the rules involves complex cascade rules that define the hierarchy of said rules. Browsers handle styles computation differently where WebKit nodes reference style objects known as RenderStyle that some nodes can share. The nodes are siblings or cousins if the elements are in the same mouse state, neither nodes have ID's, tag names match, class attributes match, their set of mapped attributes are the same, link states match, focus states match, attribute selectors don't affect either element, have no inline style attributes, have no sibling selector use at all like `+`, `:first-child` and `:last-child` selectors. Firefox meanwhile has two extra trees for easier styles computation, the rule stree and style context tree. Style contexts contain end values, which the matching rules apply in the correct order and performing manipulations transforming the rules to logical values to compute the contexts. This saves space when a percentage value transforms to absolute units and shared with other nodes. The style contexts split into structs where they contain style information for a certain category like border or color. All properties of a struct are either inherited from a parent or non-inherited as in reset or default properties. The tree helps by caching entire structs containing the computed end values enabling usage of a cached struct in an upper node if a bottom node doesn't supply a definition for a struct. Computing a style context requires first computing a path in the rule tree or using an existing one. Then the rules begin to apply in the path to fill the structs in our new style context starting at the bottom node with the highest precedence (often the most specific selector) and traverse up the tree until our struct is full. Matching rules is tricky so after parsing the stylesheet, hash maps by id, class name, tag name and a general map represent the styles according to the selector. This process eliminates 95% of the rules and rather simplifying style rules matching and both Firefox and WebKit use it.

##### How do browsers apply style rules in the correct cascade order?

The cascade order according to the CSS2 specification is from low to high, browser declarations, user normal declarations, author normal declarations, author important declarations and user important declarations. From low to high, each declaration overrides its predecessors. Declarations with the same order apply specificity rules then their order also comes into play. HTML visual attributes are author rules with low priority. Specificity as defined the CSS2 spec gives formula for quantifying specificity through the following rules, count 1 if the declaration is by a style attribute rather than a selector, which otherwise would be 0 (=a). Count the number of ID attributes in the selector (=b). Count the number of other attributes and pseudo-classes in the selector (=c) and count the number of element names and pseudo-elements in the selector (=d). Concatenating all those numbers `a,b,c,d` gives the specificity. After rule matching, WebKit sorts the rules according to the cascade rules using bubble sort for small lists and merge sort for bigger ones.

### How do browsers handle layout?

After the renderer is in the tree, it doesn't have a position and size yet, calculating these values in the browser is layout or reflow (in Firefox). HTML uses a flow based layout model meaning it can process geometry in a single pass enabling it to proceed left-to-right, top-to-bottom through the document, an exception to this is HTML tables. Layout is a recursive process beginning with the root renderer, `<html>` element of the document and recursively computes geometric information for each renderer that requires it. Browsers use the dirty bit system to avoid doing a full layout for every small change, a renderer that changes or is new marks itself and its children as dirty or needing layout. It has two flags dirty and children are dirty. Layouts have two types global; a trigger on the full render tree and incremental; where the dirty renderers will trigger. Global layout happens due to a global style change that affects all renderers like a font size change or as a result of a screen resize. Incremental layout is asynchronous when renderers are dirty. Firefox queues reflow commands for incremental layouts and a scheduler triggering batch execution of these reflow commands. WebKit also has a timer that executes an incremental layout by traversing the tree and laying out dirty renderers. Scripts asking for style information like `offsetHeight` can trigger incremental layout synchronously. Global layout is often synchronous. When a change in a renderer's position occurs but the size stays the same, the browser retrievest its size from cache and skips recalculating its layout. The layout process starts with the parent renderer determining its width, going over its children placing the child renderer and calls child layout if dirty or in global layout and calculates the child's height. Parent then uses children's accumulative heights and the heights of margins and padding to set its own height and then set its dirty bit flag to false. Firefox uses a state object `nsHTMLReflowState` as a parameter to layout and its output is a `nsHTMLReflowMetrics`, which contains the renderer's computed height. WebKit calculates width using the `RenderBox.calcWidth`, a method on the `RenderBox` class. The container width is the higher value of the container's `availableWidth` and 0. The `availableWidth` is often the `contentWidth`, which is a result of `clientWidth() - paddingLeft() - paddingRight()`. The element's width is the width style attribute, which will the browser calculates as an absolute value by computing the percentage of the container width then horizontal borders and paddings come into play. This calculation was of the preferred width, then the browser computes min and max widths then if the preferred width is greater than the max width, max width applies and if the preferred width is less than the min width, min width applies.

#### How do browsers paint?

Browsers traverse the render tree and call the renderer's `paint()` method to display content on the screen. Painting uses the UI infrastructure component of the browser. As with layout, painting can be either global or incremental. The painting order according to the CSS2 spec defines the order in which the elements stack in the stacking contexts. This order affects painting since the stacks paint from back to front. The order of a block renderer is background color, background image, border, children and then outline. Firefox traverses the render tree and builds a display list for the painted rectangle containing renderers relevant to the rectangle to paint in the correct painting order. That way ensures the tree needs one traversal for a repaint. Firefox optimizes this process by omitting hidden elements. WebKit saves the old rectangle as a bitmap then paints the delta or difference between the new and old rectangles. A rendering engine is often single-threaded. The browser main thread is an event loop, an infinite loop waiting for events like layout and paint events and processes them.

### What is the first meaningful paint?

First meaningful paint is the time it takes for a page's primary content to appear on the screen; also the first paint after which the biggest above-the-fold layout change happens and web fonts load.