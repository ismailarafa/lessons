# What are the different components of the **Git object model**?

The **git object model** is how **git** operates and stores a repository's history locally. When a repo initializes, a hidden `.git` directory also initializes with its own subdirectories often called _trees_, which in turn can have their own _subtrees_. _Trees_ or directories cannot be empty for the **git object model** to recognize it, they either have to include another _tree_ or a **blob**. A **blob** is the contents of a file. At the top of the `.git` repository, there is a `HEAD` file which points to the checked out branch. In the **objects** _tree_ within the `.git` repository houses files, directories and **commits**, while `refs` houses branches, tags and remotes. An **object** initializes when a file creation, a commit, or any **git** command occurs. The names of each **git object** is a 40 character hexadecimal hash known as SHA1 that are already unique by the 8th character in most cases. **Git objects** have types that range from **blobs**, **commits** and _trees_. Arguably, **commits** are the most important **git object** type as they are the centerpiece of the **object model**. **Commits** point to a single _tree_, have one or more parent **commits** (unless it's the **root commit**, then it has no parent), then said _tree_ points to either a **blob** or a _subtree_. The second part is _refs_. _Refs_ can be **branches**, _tags_ and **remotes**. Within the _refs_ directory, there's a heads _tree_ that stores **local branches** as files, which point to the latest **commit** on said **branch** in its file's contents. _Refs_ also store _tags_ and they also point to the **commit** associated with the _tag_. While **branches** update the **commit** they point to when more **commits** take place on said **branch**, _tags_ don't and statically point to the same **commit** when the tag initialized. Storing **remote branches** is slightly different, as for each **remote branch** name, it creates a directory with the **branches** within it. Each **branch** file like other _refs_ also point to a **commit** that changes when the **remote branch** itself has pushed updates.

## How can you manage history with **git**?

You can manage a project's history with **git** with commands like `git log` to show all **commits** in the lifespan of a project. Or to show the local **commits**, you can use the command `git reflog`. `git status` gives a status update on the files in the repository, whether they're untracked, unstaged, modified, deleted, etc...

### How can you change history with **git**?

You can unstage changes in **git** using the `git reset HEAD '[filename]'` command. To edit the **commit** message, you can use the command `git commit --amend` to rewrite the **commit** message in a text editor. You can also merge **branches**, which will result in the first **commit** made on the deviated branch as well as the last one on the original **branch** sharing a parent, which might not tell as good a story for the project as it should. This is where fast-forward merging comes in with the usage of `rebase`.

#### How can you manage remote branches and why should you always rebase locally?

You can add **remote branches** using the command `git remote add '[remotename]' '[branchURL]'`. Rebasing is the process of replaying the history of deviated **branch** over the last **commit** of the original **branch** thus rendering the series of **commits** more chronological and to seem more sequential. One way of implementing this is checking out the deviated **branch**, and then running `git rebase master` or the name of the **branch** you want to merge to. Following that, you can check out the other branch `git checkout master` and then running `git merge other-branch` to apply a fast-forward merge. You should never rebase on a **remote branch** because when you push changes, other collaborators' **git** history will be different from the one you altered and will take a lot of effort to restore the original history.

##### Why are _tags_ useful on branches when using **git**?

_Tags_ are useful when using **git**, because they provide checkpoints by pointing statically at a certain **commit**. They provide a reference to an older version of a project. There're two types of _tags_, lightweight and annotated. Generally, it's a better practice to use annotated _tags_, using the command `git tag -a '[tagname] -m '[tag annotation]''`. Moreover, you can _tag_ retroactively with the following command `git tag -a '[tagname]' [SHA1]` with the latest argument being the **commit** that the _tag_ should point to. Furthermore, when pushing work to a **remote branch**, _tags_ are never pushed unless otherwise specified. The command to push all _tags_ is `git push origin --tags`, where `origin` is the name of the **remote branch**.
